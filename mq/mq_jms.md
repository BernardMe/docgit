

# 消息队列MQ

## 一个故事告诉你什么是消息队列

### 故事案例

>有一天，产品跑来说：“我们要做一个用户注册功能，需要在用户注册成功后给用户发一封成功邮件。”
小明（攻城狮）：“好，需求很明确了。” 不就提供一个注册接口，保存用户信息，同时发起邮件调用，待邮件发送成功后，返回用户操作成功。没一会功夫，代码就写完了。验证功能没问题后，就发布上线了。
线上正常运行了一段时间，产品匆匆地跑来说：“你做的功能不行啊，运营反馈注册操作响应太慢，已经有好多用户流失了。”
小明听得一身冷汗，赶紧回去改。他发现，原先的以单线程同步阻塞的方式进行邮件发送，确实存在问题。这次，他利用了 JAVA 多线程的特性，另起线程进行邮件发送，主线程直接返回保存结果。测试通过后，赶紧发布上线。小明心想，这下总没问题了吧。
没过多久，产品又跑来了，他说：“现在，注册操作响应是快多了。但是又有新的问题了，有用户反应，邮件收不到。能否在发送邮件时，保存一下发送的结果，对于发送失败的，进行补发。”
小明一听，哎，又得熬夜加班了。产品看他一脸苦逼的样子，忙说：“邮件服务这块，别的团队都已经做好了，你不用再自己搞了，直接用他们的服务。”
小明赶紧去和邮件团队沟通，谁知他们的服务根本就不对外开放。这下小明可开始犯愁了，明知道有这么一个服务，可是偏偏又调用不了。
邮件团队的人说，“看你愁的，我给你提供了一个类似邮局信箱的东西，你往这信箱里写上你要发送的消息，以及我们约定的地址。之后你就不用再操心了，我们自然能从约定的地址中取得消息，进行邮件的相应操作。”

>>后来，小明才知道，这就是外界广为流传的消息队列。
`你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。`
对应的服务自然能监听到你发送的消息，进行后续的操作。


### 消息队列最大的特点
`将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。`





# 规范

## 来源

在介绍activemq之前，先简单介绍JMS，它是J2EE的13个规范之一，提供的是消息中间件的规范。



## JMS规范


### 基本组成

JMS包括以下基本构件：

　　　连接工厂，是客户用来创建连接的对象，ActiveMQ提供的是ActiveMQConnectionFactory；

　　　连接connection；

　　　会话session，是发送和接收消息的上下文，用于创建消息生产者，消息消费者，相比rocketMQ会话session是提供事务性的；

　　　目的地destination，指定生产消息的目的地和消费消息的来源对象；

　　　生产者、消费者，由会话创建的对象，顾名思义。



### 消息通信机制

点对点模式，每个消息只有1个消费者，它的目的地称为queue队列；

发布/订阅模式，每个消息可以有多个消费者，而且订阅一个主题的消费者，只能消费自它订阅之后发布的消息


### 　消息确认机制

　　　Session.AUTO_ACKNOWLEDGE，直接使用receive方法。
　　　Session.CLIENT_ACKNOWLEDGE，通过消息的acknowledge 方法确认消息。
　　　Session.DUPS_ACKNOWLEDGE，该选择只是会话迟钝第确认消息的提交。如果JMS provider 失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider 必须把消息头的JMSRedelivered 字段设置为true






## 知识点


### 

Queues:是队列方式消息

Topics:是主题方式消息

Subscribers:消息订阅监控查询

Connections:可以查看链接数，分别可以查看xmpp、ssl、stomp、openwire、ws和网络链接

Network:是网络链接数监控

Send:可以发送消息数据


### 消息中间件构建要素

Broker
消息服务器，为server提供消息核心服务

Producer
消息生产者，业务的发起方，负责生产消息传输给broker

Consumer
消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理

Topic
主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播

Queue
队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收

Message
消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输



### 消息中间件模式运行模式

####  点对点模式
消息生产者生产消息发送到queue中，消息消费者从queue中取出并且消费消息。Queue支持存在多个消费者，但是每一个消息，只会有一个消费者可以消费，此消息消费后，队里queue便不再存储

#### 消费订阅模式

topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息。


