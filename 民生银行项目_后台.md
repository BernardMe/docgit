[TOC]

# SVN
账号jianghaibo
密码jianghaibo@3343

# 网络配置(建议固定IP)
IPv4 Address: 10.0.163.176
IPv4 Subnet Mask: 255.255.248.0
IPv4 Default Gateway: 10.0.167.254
IPv4 DNS Servers: 10.0.5.139, 221.130.33.60


# 项目介绍

## 项目业务相关

>2017年最主要的需求就是 `鑫愿贺卡小助手`手机移动端功能

### 鑫愿贺卡小助手
鑫愿商城小程序-积分商城、贺卡功能的开发；小程序以“鑫愿贺卡小助手”形式重新定义用途，以可分享的贺卡小工具为载体，增加有趣的积分排行-兑换功能，通过玩贺卡获得积分的方式，促进商城销售。
积分兑换功能的优化：小程序功能目录页面，积分商城，积分流水、积分转赠、积分排行、个人信息，并拥有独立的展业页面 。



表B_agent代理人(鑫愿贺卡有关)

表KMH_
代表业务 开门红

表PDD_
代表业务 拼多多

表WX_
一般代表后台管理

表XB_
代表业务 续保


*更细节的需求文档请参考MinSheng需求文件夹*

## mslife_wx 公众号
前后台完全分离
web项目
用框架SpringMVC+Spring3+Hibernate3

### 项目开发环境
JDK1.6
Tomcat7.0


### 利用 Spring IoC 配置 EHCache 
从 Spring 1.1.1 开始，EHCache 就作为一种通用缓存解决方案集成进 Spring。 
我将示范拦截器的例子，它能把方法返回的结果缓存起来。
  利用 Spring IoC 配置 EHCache 
在 Spring 里配置 EHCache 很简单。你只需一个 ehcache.xml 文件，该文件用于配置 EHCache：
```xml
<ehcache>
    <!-- 设置缓存文件 .data 的创建路径。
         如果该路径是 Java 系统参数，当前虚拟机会重新赋值。
         下面的参数这样解释：
         user.home – 用户主目录
         user.dir      – 用户当前工作目录
         java.io.tmpdir – 默认临时文件路径 -->
    <diskStore path="java.io.tmpdir"/>

    <!-- 缺省缓存配置。CacheManager 会把这些配置应用到程序中。
        下列属性是 defaultCache 必须的：
        maxInMemory           - 设定内存中创建对象的最大值。
        eternal                        - 设置元素（译注：内存中对象）是否永久驻留。如果是，将忽略超
                                              时限制且元素永不消亡。
        timeToIdleSeconds  - 设置某个元素消亡前的停顿时间。
                                              也就是在一个元素消亡之前，两次访问时间的最大时间间隔值。
                                              这只能在元素不是永久驻留时有效（译注：如果对象永恒不灭，则
                                              设置该属性也无用）。
                                              如果该值是 0 就意味着元素可以停顿无穷长的时间。
        timeToLiveSeconds - 为元素设置消亡前的生存时间。
                                               也就是一个元素从构建到消亡的最大时间间隔值。
                                               这只能在元素不是永久驻留时有效。
        overflowToDisk        - 设置当内存中缓存达到 maxInMemory 限制时元素是否可写到磁盘
                                               上。
        -->
    <cache name="org.taha.cache.METHOD_CACHE"
        maxElementsInMemory="300"
        eternal="false"
        timeToIdleSeconds="500"
        timeToLiveSeconds="500"
        overflowToDisk="true"
        />
</ehcache>
```
EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。
Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点



## mslife_wx_back_management 微管家后台系统
>(管理员行为)微管家后台系统->数据库

### 项目开发环境

JDK1.6
Tomcat7.0

oracle数据库地址10.0.12.31:1521/testlis
用户名密码wxcedb/wxcedb

Struts2+Spring3+Hibernate3

### Cookie中URL解码后内容
```json
managerWxAccountList=[{"region":"","appId":"wxbb84fc1d0b21d7df","lastUserStatisticsTime":"","qrCode":"","type":"1","blog":"","password":"","url":"","lastGetWXUserAttationtTime":0,"id":"297e51155a4a1da3015a4a21cc060004","certification":"1","loginEmail":"","token":"minshengwxtest","name":"民生微管家","head":"","functionIntroduction":"","appSecret":"0a0ac742091059c196697b5b7fb5e1e8","openId":"gh_9643de2e724d"}]
```

### struts2配置


例如
```xml
<package name = "noticeRemind" extends = "struts-default" namespace = "/wishgift/action">
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>
```
namespace /wishgift/action 对应 wx.wishgift.action

#### Action采用属性驱动
 在Action类中，属性××通过get××()和set××()方法，把参数在整个生命周期内进行传递，这就是属性驱动


### Spring配置

#### Spring使用property文件作为配置源
工程中难免出现一些需要每次部署都需要配置的参数，如数据源连接参数等，测试环境跟实际运行环境是不一样的。
使用spring框架的话，`这些参数可能独立分布在不同的springContex配置文件里面`。
可以考虑将这些参数独立到一个配置文件并可以让spring方便加载注入。可选的一个方案是使用java的property文件，将所有的配置参数都写到property文件里面，使用${key}来在spring配置文件里面得到这个参数。

例子：
property文件global-config-file.properties：
```shell
#FOR dataSource
jdbc.dataSource.url=jdbc:postgresql://192.168.1.118:5432/DB_name
jdbc.dataSource.username=postgres
jdbc.dataSource.password=123
```

示例配置的是数据源参数。
 
之后在springContext的配置文件中，加入下面代码，：
```xml
<!-- 在spring配置文件中 引入xmlns:context命名空间 -->
<beans xmlns:aop="http://www.springframework.org/schema/aop"  xmlns:context="http://www.springframework.org/schema/context">

    <bean id="propertyConfigurer"  
           class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
         <property name="ignoreUnresolvablePlaceholders" value="true" />
         <property name="location" value="classpath:global-config-file.properties"/>  
     </bean>

    <!-- 或者如下 -->
    <bean id="propertyConfig"
        class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>/WEB-INF/classes/dbConection.properties</value>
                <value>/WEB-INF/classes/wifidogcode.properties</value>
                    <!--<value>classpath:jdbc.properties</value> -->
                    <!--<value>classpath:config.properties</value> -->
            </list>
        </property>
    </bean>
</beans>
 ```
即引入PropertyPlaceholderConfigurer来读取property配置文件，spring框架会从其那里获取到需要的配置参数。
之后再用${key}的格式取代你数据源配置参数：
```xml
<bean id="myBatisDataSource" class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="org.postgresql.Driver">
    </property>
    <property name="url" value="${jdbc.dataSource.url}"></property>
    <property name="username" value="${jdbc.dataSource.username}"></property>
    <property name="password" value="${jdbc.dataSource.password}"></property>
</bean>
```
例如：${jdbc.dataSourcurl}：框架会将global-config-file.properties读到jdbc.dataSource.url的值“jdbc:postgresql://192.168.1.118:5432/DB_name”填入${jdbc.dataSource.url}所在的位置。



#### Spring 容器 
相当于一个总配置文件
```xml
<beans>

    <!-- 是用于激活那些已经在spring容器里注册过的bean（无论是通过xml的方式还是通过package scanning的方式）上面的@注解 -->
    <context:annotation-config></context:annotation-config>
    <context:component-scan base-package="wx"></context:component-scan>

    <!-- Properties Start -->
    <bean id="propertyConfig"
        class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>/WEB-INF/classes/dbConection.properties</value>
                <value>/WEB-INF/classes/wifidogcode.properties</value>
<!--                <value>classpath:jdbc.properties</value> -->
<!--                <value>classpath:config.properties</value> -->
            </list>
        </property>
    </bean>

    <bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <!-- hibernate两种映射方式 -->
        <!-- 注解方式(在POJO对象的属性上) -->
        <property name="annotatedClasses">
            <list>
                <value>wx.experiencer.model.Experiencer</value>
            </list>
        </property>
        <!-- hbm.xml配置方式 -->
        <property name="mappingResources">
            <list>
                <value>wx/nationsky/vo/WXManager.hbm.xml</value>
            </list>
        </property>
         <property name="hibernateProperties">
                <props>
                    <prop key="hibernate.dialect">${hibernate.dialect}</prop>
                    <prop key="hibernate.jdbc.fetch_size">${hibernate.jdbc.fetch_size}</prop>
                    <prop key="hibernate.jdbc.batch_size">${hibernate.jdbc.batch_size}</prop>
                </props>
        </property>
    </bean>
    
    <bean id="hibernateTransactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
    </bean>

    <tx:advice id="txadvice" transaction-manager="hibernateTransactionManager">
        <tx:attributes>
            <tx:method name="save*" propagation="REQUIRED" />
            <tx:method name="add*" propagation="REQUIRED" />
           ...
        </tx:attributes>
    </tx:advice>


    <!-- 给事务配置一个切面 -->
    <aop:config>
        <aop:pointcut expression="(execution (* *.*.service..*(..)))" id="txPointcut" />
        <aop:advisor advice-ref="txadvice" pointcut-ref="txPointcut" />
    </aop:config>

    <!-- 注入HibernaeTemplate实例，作为持久层访问模板 -->
    <bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate">
        <property name="sessionFactory">
            <ref bean="sessionFactory" />
        </property>
    </bean>

    <!-- 引入额外的配置 相当于分模块 使配置结构更加清晰化 -->
    <import resource="wx_spring.xml"/>

</beans>
```

### 事务传播行为

#### PROPGATION_REQUIRED
PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务



例如
```xml
<!-- 微信管理员 -->
<bean id="WXManagerAction" class="wx.wxmanager.action.WXManagerAction" scope="prototype" >      
    <property name="wxManagerService" ref="WXManagerService"></property>
    <property name="wxAccountService" ref="WXAccountService"></property>
    <property name="wxManagerAndWxAccountService" ref="WxManagerAndWxAccountService"></property>
    <property name="logService" ref="SysOparateLogService"></property>
</bean>
<bean id="WXManagerService" class="wx.wxmanager.service.impl.WXManagerServiceImpl"  > 
    <property name="wxManagerDao" ref="WXManagerDao"></property>
</bean>
<bean id="WXManagerDao" class="wx.wxmanager.dao.impl.WXManagerDaoImpl"> 
    <property name="hibernateTemplate" ref="hibernateTemplate"></property>
</bean>
```

### JDBC配置

```properties
hibernate.dialect=org.hibernate.dialect.OracleDialect
 
hibernate.hbm2ddl.auto=update
```
hibernate.hbm2ddl.auto参数的作用
update
最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），
以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。


 

### Hibernate配置
使用POJO对象+hbm.xml，对象属性映射于表中的字段
例如
```xml
<hibernate-mapping>
    <class name = "wx.experiencer.model.Gift" table = "kmh_gift">
        <id name = "id">
            <generator class = "uuid"/>
        </id>
        <property name = "isDirectional"/>
        <property name = "amount"/>
        <property name = "deliveredQuantity" column = "DELIVEREDQUANTITY"/>
        <property name = "detailURL"/>
        <property name = "giftNO"/>
        <property name = "info"/>
        ...
    </class>
</hibernate-mapping>
```

Spring整合Hibernate后，dao组件都默认注入HibernaeTemplate实例，传参时传入VO




### 页面

项目页面以servlet/jsp为主(绝大部分页面中js在scirpt标签嵌入)

```html
<c:forEach items = "${Gifts}" var = "gift">
    <tr style="background-color: FFFFFF; text-align: center;">
        <td class = "Able_Steven_td"><%=i++ %><input name = "gift_Id" type = "hidden" value = "${gift.id }" /><input type = "hidden" name = "gift_orderIndex" value = "${gift.orderIndex}"><c:forEach items = "${gift.types}" var = "type"><input class = "typeIds" type = "hidden" value = "${type.id }"/></c:forEach></td>
        ...
    </tr>
</c:forEach>
```


#### 图片上传
页面form表单中的上传文件控件
```html
<input type="file" name="img" />
```

action中添加两个属性
```java
    private String uploadBasePath = Config.getProperty("giftPic")+"titleIcon/";
    private Logger log = Logger.getLogger(TitleIconAction.class);
    
    //前端上传插件通过struts2属性驱动传入action两个属性(通过setter)
    private File img;
    private String imgFileName;
```

jsp展示页面使用流方式读取
```html
<%@ page import="wx.nationsky.util.Config" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
    String imgBasePath = Config.getProperty("get_img_path"); //读取配置文件中访问mslife_wx(公众号)系统中读取已上传图片的请求接口
%>

<td class="js_td"><img src="<%=imgBasePath%>${title.titleIconImgPath}" height="50" width="80" /></td>
```



## mslife_wx_mimiprogram 微信小程序
>前后台完全分离(前台是手机移动端,没有PC浏览器端)
(客户行为)小程序前台客户端调用小程序后台->数据库


# 开发流程

## 3.1. 架构设计

分层开发
按功能分包
命名 wx.功能.xxx
xxx=vo,dao,service,action

### 实体类包
一般名命xx.xx.model或xx.xx.vo


### action层

#### 主要点
- 基本上不用ajax，都使用的是jsp/Servlet的request，session等作用域
- 一些表单验证(如id，名称唯一性验证)，请求后台接口使用ajax

#### Struts2框架下请求接口命名模式
struts.xml配置 action属于哪一个 namespace下面 xxx_yyy
对应xxxAction中的yyy方法
例如:
`miniGift_add`
配置方式
```xml
<package name="nationsky" extends="struts-default" namespace="/">
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>

<package name="experiencer" extends="struts-default" namespace="/experiencer/action">
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>
```
`/experiencer/action`和experience.action并不是相对应

`namespace="/"` 实际转发到 / namespace下面

#### 基础Action类 BaseAction
//日志文件 1成功 2失败 //左边菜单列表 //分页对象 //当前页对象 //页面返回值(result路径,控制器分发时使用->${result})

#### 文件上传示例
前端jsp中form表单的input表单域上传控件
`<input type="file" name="img" class="txt" style="width:60px;" value="">`

```java
@Component
@Scope("prototype")
public class TitleIconAction extends BaseAction {
    private File img;
    private String imgFileName;

    //属性的getter setter方法
    public File getImg() {
        return img;
    }

    public void setImg(File img) {
        this.img = img;
    }

    public String getImgFileName() {
        return imgFileName;
    }

    public void setImgFileName(String imgFileName) {
        this.imgFileName = imgFileName;
    }

    public String add() {
        //验证vo对象属性titleIcon 图片非空
        if (null == titleIcon || null == img || imgFileName.equals("")){
            this.addActionMessage("图片不能为空");
            log.info("======= exception for add() of " + TitleIconAction.class.toString() + "图片不能为空");
            result = "titleIcon_forTitleIconListPage";
            return "chain";
        }

        try {
            //使用文件上传工具类获取存储磁盘后的String类型的图片存储路径
            String imgPath = ImgUtility.saveImg(img, imgFileName, uploadBasePath);
            //给VO对象赋值上传图片的路径
            titleIcon.setTitleIconImgPath(imgPath);
            service.saveTitleIcon(titleIcon);
            result = "titleIcon_forTitleIconListPage";
        } catch(Throwable e) {
            PrintErr.printErr(e, log);
            result = "brandManage/brandMain.jsp";
            return SUCCESS;
        }
    }
}
```
上传文件需要传递参数 (img imgFileName分别对应action中File类型，String类型属性)


Spring在Action上面注解@Scope("prototype")
表示每次接收一个请求创建一个Action对象..
如若改成其他,例如单例模式,则很多请求公用同一个Action.

```java
@Component
@Scope("prototype")
public class TitleIconAction extends BaseAction {
}
```

### service层
声明式事务配置AOP切面在Service层的方法

```xml
<!-- 给事务配置一个切面 -->
<aop:config>
    <aop:pointcut expression="(execution (* *.*.service..*(..)))" id="txPointcut" />
    <aop:advisor advice-ref="txadvice" pointcut-ref="txPointcut" />
</aop:config>
```

#### service层可配置内容
可以在service层添加验证逻辑，在Action层调用
```java
public boolean validateForm(GoodsInfo good) {
        boolean flag = false;
        //验证vo对象属性礼品编号或名称非空
        if (null == good || "".equals(good.getGoodsNo()) || "".equals(good.getName())){
            log.info("======= exception for validateForm() of " + MiniGiftServiceImpl.class.toString() + "礼品编号或名称不能为空");
            flag = true;
        }

        //可扩展其他的验证
        //...
        return flag;
    }
```

### dao层
基础dao类 BaseDaoImpl(多例)
```java
/**
 * 顶层持久化层实现类
 * @author xiaohuiyang
 *
 */
@Component
@Scope("prototype")
public abstract class BaseDaoImpl extends HibernateDaoSupport implements BaseDao {
    private Logger log = Logger.getLogger(TitleIconDaoImpl.class);

}
```

注入HibernaeTemplate实例，作为持久层访问模板
```java
@Override
public TitleIcon findById(String id) {
    log.info("======= log for findById() of " + TitleIconDaoImpl.class);

    TitleIcon titleIcon = null;
    try {
        //使用注入的HibernateTemplate实例执行持久化操作，传参时传入VO
        titleIcon = (TitleIcon) getHibernateTemplate().get(TitleIcon.class, id);
    } catch (Exception e) {
        //使用PrintErr工具类打印异常到日志
        PrintErr.printErr(e, log);
    } finally {
        flushSession();
        clearSession();
    }

    log.info("======= log for findById() of " + TitleIconDaoImpl.class + "ends.");
    return titleIcon;
}
```

注意事务管理
Spring容器配置事务传播行为统一使用 PROPGATION_REQUIRED
`  <tx:method name="save*" propagation="REQUIRED" />`

PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务


### 数据库层

#### 主要点
使用Hibernate配置id生成策略都是用uuid



数据库服务器
oracle11g SIMPLIFIED CHINESE_CHINA.ZHS16GBK
编码使用


客户端
推荐使用PL/SQL客户端(注：需要下载32位oracle客户端压缩包，配置方式百度之)

新建一个bat批处理，设置数据库client编码(session的级别)
```shell
set NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK
"F:\PLSQL Developer\plsqldev.exe"
```

### 业务相关

>2017年最主要的需求就是 `鑫愿贺卡小助手`手机移动端功能

#### 鑫愿贺卡小助手
鑫愿商城小程序-积分商城、贺卡功能的开发；小程序以“鑫愿贺卡小助手”形式重新定义用途，以可分享的贺卡小工具为载体，增加有趣的积分排行-兑换功能，通过玩贺卡获得积分的方式，促进商城销售。
积分兑换功能的优化：小程序功能目录页面，积分商城，积分流水、积分转赠、积分排行、个人信息，并拥有独立的展业页面 。


表B_agent代理人(鑫愿贺卡有关)

表KMH_
代表业务 开门红

表PDD_
代表业务 拼多多

表WX_
一般代表后台管理

表XB_
代表业务 续保




## 3.2. 简单开发示例设计

`示例设计_鑫愿贺卡_商城标题图管理`

### 功能开发

在wx.wishgift.action包下面新增

titleIconList.jsp
TitleIconAction(Struts2控制器)
```java
package wx.wishgift.action;

@Component
@Scope("prototype")
public class TitleIconAction extends BaseAction {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    @Autowired
    private TitleIconService service;

    private String uploadBasePath = Config.getProperty("giftPic")+"titleIcon/";
    private Logger log = Logger.getLogger(TitleIconAction.class);
    
    private List<TitleIcon> titles;
    private TitleIcon titleIcon;
    private String titleIconId;
    private File img;
    private String imgFileName;

    //********* Getter And Setter ***********
    
    public List<TitleIcon> getTitles() {
        return titles;
    }

    public void setTitles(List<TitleIcon> titles) {
        this.titles = titles;
    }

    public TitleIcon getTitleIcon() {
        return titleIcon;
    }

    public void setTitleIcon(TitleIcon titleIcon) {
        this.titleIcon = titleIcon;
    }

    //******** Request Handler ***********
    
    public String forTitleIconListPage() {
        log.info("=======log for forTitleIconListPage()");

        titles = service.listAllTitles();
        result = "page/wishgift/titleIconList.jsp";

        log.info("=======log for forTitleIconListPage() ends");
        return SUCCESS;
    }

    //新增方法
    public String add() {
        log.info("======= log for add() of " + TitleIconAction.class.toString());

        //验证vo对象属性titleIcon 图片非空
        if (null == titleIcon || null == img || imgFileName.equals("")){
            this.addActionMessage("图片不能为空");
            log.info("======= exception for add() of " + TitleIconAction.class.toString() + "图片不能为空");
            result = "titleIcon_forTitleIconListPage";
            return "chain";
        }

        //验证vo对象属性titleIconId是否已存在 true 说明库中没有
        if (service.uniqueTitleIconId(titleIconId)){
            try {
                String imgPath = ImgUtility.saveImg(img, imgFileName, uploadBasePath);

                //给VO对象赋值上传图片的路径
                titleIcon.setTitleIconImgPath(imgPath);

                service.saveTitleIcon(titleIcon);

                result = "titleIcon_forTitleIconListPage";
            } catch(Throwable e) {
                PrintErr.printErr(e, log);
                result = "brandManage/brandMain.jsp";
                return SUCCESS;
            }
        } else {
            this.addActionMessage("该titleIconId已存在");
            result = "该titleIconId已存在";
            return INPUT;
        }


        log.info("======= log for add() of " + TitleIconAction.class.toString() + " ends.");
        return "redirect";
    }

    //其他控制器方法，修改，删除，等方法

    }
}

```

TitleIconService
```java
package wx.wishgift.service;

import java.util.List;

import wx.nationsky.service.BaseService;
import wx.wishgift.model.TitleIcon;

public interface TitleIconService extends BaseService {
    List<TitleIcon> listAllTitles();

    TitleIcon findById(String id);
    boolean uniqueTitleIconId(String titleIconId);
    boolean saveTitleIcon(TitleIcon titleIcon);
    boolean updateTitleIcon(TitleIcon titleIcon);
    boolean deleteTitleIcon(TitleIcon titleIcon);
}
```
TitleIconDao
```java
package wx.wishgift.dao;

import java.util.List;

import wx.nationsky.dao.BaseDao;
import wx.wishgift.model.TitleIcon;

public interface TitleIconDao extends BaseDao {
    List<TitleIcon> findAll();
    TitleIcon findById(String titleIconId);
    boolean uniqueTitleIconId(String titleIconId);
    boolean saveTitleIcon(TitleIcon titleIcon);
    boolean updateTitleIcon(TitleIcon titleIcon);
    boolean deleteTitleIcon(TitleIcon titleIcon);
}
```


### 数据表
KMH_TITLEICON


### 使用POSTMAN进行开发后台接口

从JSP--TitleIconAction--TitleIconService--TitleIconDao--Oracle


## 3.3 接口开发示例

### mslife_wx 公众号
该项目的请求接口统一使用
`ip:端口/项目名称/控制器名称/requestMapping名称.json`
的格式


springmvc是基于servlet，web.xml中配置一个servlet，会做请求分发，还有一系列其它处理
因为该项目使用SpringMVC，并且在web.xml中配置如下
```xml
<!--springmvc的核心是DispatcherServlet，它负责控制整个页面的请求路径-->  
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
     <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:resource/spring/spring-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>*.json</url-pattern>
</servlet-mapping>
```


### mslife_wx_back_management 微管家后台系统
该项目的请求接口统一使用
`http://ip:端口/项目名称/Action名称(不带Action后缀)_Action中方法名称`
的格式


### mslife_wx_mimiprogram 微信小程序



### 接口文档
主要结构
包括接口功能名称，接口调用请求说明，请求方式，请求参数说明，返回说明，返回参数说明

获取商城标题图列表

接口调用请求说明
`http://mswgj.minshenglife.com/mslife_wx/titleIcon/getTitleIconList.json`

请求方式：GET

请求参数说明
参数  是否必须    说明

返回说明
```json
{
    "status": {
        "code": 0,
        "msg": ""
    },
        "data":{
            "titleIconList":[
{"titleIconId":"8a8023055fb47f23015fb4c74e840001","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/f6f24b33.50bb.4dc0.b414.00df251b9b7a-1922236980.jpg","titleIconURL":"111","titleIconSort":-1},
{"titleIconId":"8a8023055fb47f23015fb480b6980000","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/a959bccd.5005.4c46.9f5c.1936223a63811848602103.jpg","titleIconURL":"999","titleIconSort":0},
{"titleIconId":"8a8023055fb40b10015fb45a535c0001","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/7a75f9ac.1b9a.4a2e.b681.14d6aa9dd127-423361007.jpg","titleIconURL":"777","titleIconSort":1},
{"titleIconId":"8a8023055fb40b10015fb458e5dc0000","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/7b85ca1a.9df3.480a.82e0.37a3566cfa111531658263.jpg","titleIconURL":"666","titleIconSort":1},
{"titleIconId":"2","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/6dc2d733.9d44.420d.ac28.ceea17c1cca01351015038.jpg","titleIconURL":"Wildhorse","titleIconSort":2},
{"titleIconId":"8a8024595fb83330015fb83981c10000","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/51f0b149.4767.4f2b.b10f.a02578e346bb-1345260926.jpg","titleIconURL":"gyjh少林寺","titleIconSort":9}
        ]
    }
}
```

返回参数说明：
参数  说明
code    0：成功
msg 
titleIconList   返回的商城标题图list
titleIconId 商城标题图id
titleIconImgPath    标题图存储路径
titleIconURL    标题图用户输入的URL
titleIconSort   标题图用户输入的排序(值越小越靠前)



更多其他接口文档请参照
`民生保险项目文档/接口文档/`下面的接口文档


# 测试流程


测试版本都要部署到测试服务器上，每次系统上测试服务器需要先更新SVN库最新代码后编译打包部署到服务器(可以和江海波沟通一下)

各个项目对应服务器地址如下，可通过xshell链接操作：
公众号&&后台管理 ssh:
ip:10.0.158.27 

账号：weblogic
密码：password weixin

小程序测试环境：
ip:10.0.158.26 

账号：wxusr
密码：password


部署方法
```shell
cd /data
mv mslife_wx.war 备份名
rz -y 
ps ef|grep java
kill -9 进程号
nohup ./startWebLogic.sh > nohup.out  2>&1 &
```


# 部署运维流程



# 模块指南

## 微管家后台管理系统

- 鑫愿贺卡
    + 礼物管理
    + 供应商礼品管理
    + 供应商管理
    + 公告管理
    + 提示按钮的设置
    + 中支管理
    + 集采订单管理
    + 中支集采订单管理
    + 积分红包卡充值记录
    + 问答管理
    + 商城标题图管理
    + 统计报表
- 微信公众号管理
    + 账号添加
    + 账号编辑
    + 设置OpenID
- 小程序管理
    + 小程序礼物管理
