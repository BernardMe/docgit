[TOC]

# SVN
账号jianghaibo
密码jianghaibo@3343

# 网络配置(建议固定IP)

## 无线网
IPv4 Address: 10.0.163.176
IPv4 Subnet Mask: 255.255.248.0
IPv4 Default Gateway: 10.0.167.254
IPv4 DNS Servers: 10.0.5.139, 221.130.33.60

## 有线网
IPv4 Address: 10.0.16.220
IPv4 Subnet Mask: 255.255.250.0
IPv4 Default Gateway: 10.0.16.254
IPv4 DNS Servers: 10.6.42.41, 10.0.5.140


# 项目介绍

## 业务相关

### 总览

目前在mslife_wx项目中的贺卡功能，是一个过渡性临时性的产品，
在小程序的鑫愿商城建成后，将把mslife_wx项目中的贺卡功能移除掉，以积分逐渐取代贺卡
所以重点还是在mslife_miniprogram中的鑫愿商城功能



#### 最新业务需求整理(鑫愿商城拼单/积分抵现功能)

后台管理

`王卓` 已完成发布测试版本2.0
礼品管理设置：是否拼单，拼单结束时间，拼单购买金额，拼单人数，是否积分特惠礼品。
单独设置拼单库存？

`江海波`
多供应商订单通用接口：不同的供应商可发布礼品，管理通过审核后即可上线。每个供应商
只可看到自己发布的礼品。订单接口可对接供应商财务系统，订单系统，支付下单对应不同的供应商

`备注`
以上仅是鑫愿商城此次新功能页面修改，没提及页面不做修改
由于拼单功能涉及到退款操作，第三方接口需要变动，具体接口变动需要和第三方协调对接
贺卡剥离，新用户输入工号后，直接进入商城页


#### 重要节点

开会提到：
12月25日之前，要把`鑫愿商城拼单/积分抵现功能`确定完成(25日后不能再动)，25日正式上线(为元旦期间向用户开放)

12月19日完成目前在做的`拼多多订单管理(包含模糊查询 为订单号绑定快递运单号 )` 可能有批量导入需求




### 开门红业务
原先在mslife_wx项目中，拥有开门红业务，后来在开门红中添加了鑫愿贺卡功能，但是在mslife_wx公众号项目中，还有保险相关业务，所以想要通过微信小程序这个载体，搭建业务更独立完整的鑫愿商城
使得mslife_wx公众号项目更加专注于保险相关业务。

####　开门红业务分公司部门使用场景

为各家分公司提供专属的后台账号及密码，可从后台导出以下数据：
1.机构：分公司、下级机构（A分公司只能导出A的信息，无能导出B的）
2.业务伙伴信息：姓名、工号、获客清单
3.客户信息：姓名、联系方式、地址、心愿礼物、礼物是否已付款、订单是否已确认、是否已发货
4.统计信息：代理人参与人数/人次、客户参与人数/人次、点击加入心愿的人次、扫码进入参与的人数/人次、客户分享进入参与的人数/人次、云助理进入参与的人数/人次、微管家分享链接进入参与的人数/人次


分公司名称、分公司代码、三级机构名称、三级机构代码，还有渠道：营销、收展、其他 

>最终的就是:将客户从公众号项目的鑫愿贺卡功能-->到鑫愿商城小程序中

>2017年最主要的需求就是 `鑫愿贺卡小助手`手机移动端功能

### 鑫愿贺卡小助手
鑫愿商城小程序-积分商城、贺卡功能的开发；小程序以“鑫愿贺卡小助手”形式重新定义用途，以可分享的贺卡小工具为载体，增加有趣的积分排行-兑换功能，通过玩贺卡获得积分的方式，促进商城销售。
积分兑换功能的优化：小程序功能目录页面，积分商城，积分流水、积分转赠、积分排行、个人信息，并拥有独立的展业页面 。

#### 功能流程说明
`全产品定向秒杀功能`：
定向秒杀可以选择针对哪些购买了某一保险产品的客户或者销售成功的代理人开放，购买该产品的客户或者代理人等，可获得秒杀该礼物的资格。
![全产品定向秒杀功能](./全产品定向秒杀功能.png)


说明：
1.客户秒杀单次仅可秒杀一件，代理人可秒杀多件；
2. 均不可超过最大秒杀数；
3.灰色为不可修改;
4.代理人若获得秒杀资格，需在犹豫期之后为撤单，可获得秒杀权利

`内购集采功能`：
开通一个模块，（流程）全国已中支为单位下发账号密码（每个公司授权一个账号可登录使用该功能），该模块可批量预定商品，并确认收件人和地址信息，不用线上支付货款，但须在总公司审批同意后，订单发送至供货方；[表单内容跟订单基本一样，商品名字（可选），数量，
地址，联系方式，联系人，希望到货时间，备注。]



### 微管家
本期开发目的为：拆分现有商城中积分模块、贺卡模块变为小程序，商城独立在微管家中单独运行，仅保留客户管理、商城等功能；

1.  鑫愿商城小程序-积分商城、贺卡功能的开发；小程序以“鑫愿贺卡小助手”形式重新定义用途，以可分享的贺卡小工具为载体，增加有趣的积分排行-兑换功能，通过玩贺卡获得积分的方式，促进商城销售。
2.  鑫愿商城-拼单功能、积分抵现、满额打折（免邮）功能：在鑫愿商城中实现组团拼单（可多人拼单，后台可以设置人数上限，拼单价），可设置“积分特惠”商品促使积分使用，可设置达到购买某种特定商品达到某个额，可以减价幅度（可设置具体金额）。
3.  鑫愿商城等级变化:用户等级增长升为17级，在现有积分基础上（20000分=10级），增加11级23000分，12级25000分，13级30000分，14级40000分，17级（100000分）
4.  鑫愿商城多供应商订单通用的接口，设计一个可对外发布的通用接口，用于外部供应商财务系统、订单系统的接入，并形成固定文档，便于我部对外拓展。
5.  提升鑫愿商城（贺卡）打开响应时间，最好在网络良好的前提下2秒以内能够打开（目前鑫愿贺卡老客户当天首次打开，大约需要加载11秒以上）。
6.  积分兑换功能的优化：增加积分兑换功能的商品页面，目录页面，拥有单独的页面显示积分流水、积分转赠、积分排行、积分商城、个人信息、其它、等，并拥有独立的商品展业页面
7.  后台：增加积分商城商品后台、增加积分排行统计、个人代理人点赞排行统计、积分商城销售清单、统计表（或在元清单中加入识别标签）。
8.  所有客户、代理人，用户操作在有确认步骤的前提下，进行微信消息推送的提醒
9.  商城首页（鑫愿商城标题图）可在后台进行自由切换，并进行超链接设置（0-10个）


### 业务相关表明名方式
表B_agent代理人(鑫愿贺卡有关)

表KMH_
代表业务 开门红

表PDD_
代表业务 拼多多

表WX_
一般代表后台管理

表XB_
代表业务 续保


*更细节的需求文档请参考MinSheng需求文件夹*



## 技术相关

## mslife_wx 公众号
前后台完全分离
web项目
用框架SpringMVC+Spring3+Hibernate3

### 项目开发环境
JDK1.6
Tomcat7.0


### 利用 Spring IoC 配置 EHCache 
从 Spring 1.1.1 开始，EHCache 就作为一种通用缓存解决方案集成进 Spring。 
我将示范拦截器的例子，它能把方法返回的结果缓存起来。
  利用 Spring IoC 配置 EHCache 
在 Spring 里配置 EHCache 很简单。你只需一个 ehcache.xml 文件，该文件用于配置 EHCache：
```xml
<ehcache>
    <!-- 设置缓存文件 .data 的创建路径。
         如果该路径是 Java 系统参数，当前虚拟机会重新赋值。
         下面的参数这样解释：
         user.home – 用户主目录
         user.dir      – 用户当前工作目录
         java.io.tmpdir – 默认临时文件路径 -->
    <diskStore path="java.io.tmpdir"/>

    <!-- 缺省缓存配置。CacheManager 会把这些配置应用到程序中。
        下列属性是 defaultCache 必须的：
        maxInMemory           - 设定内存中创建对象的最大值。
        eternal                        - 设置元素（译注：内存中对象）是否永久驻留。如果是，将忽略超
                                              时限制且元素永不消亡。
        timeToIdleSeconds  - 设置某个元素消亡前的停顿时间。
                                              也就是在一个元素消亡之前，两次访问时间的最大时间间隔值。
                                              这只能在元素不是永久驻留时有效（译注：如果对象永恒不灭，则
                                              设置该属性也无用）。
                                              如果该值是 0 就意味着元素可以停顿无穷长的时间。
        timeToLiveSeconds - 为元素设置消亡前的生存时间。
                                               也就是一个元素从构建到消亡的最大时间间隔值。
                                               这只能在元素不是永久驻留时有效。
        overflowToDisk        - 设置当内存中缓存达到 maxInMemory 限制时元素是否可写到磁盘
                                               上。
        -->
    <cache name="org.taha.cache.METHOD_CACHE"
        maxElementsInMemory="300"
        eternal="false"
        timeToIdleSeconds="500"
        timeToLiveSeconds="500"
        overflowToDisk="true"
        />
</ehcache>
```
EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。
Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点



## mslife_wx_back_management 微管家后台系统
>(管理员行为)微管家后台系统->数据库

### 项目开发环境

JDK1.6
Tomcat7.0

oracle数据库地址10.0.12.31:1521/testlis
用户名密码wxcedb/wxcedb

Struts2+Spring3+Hibernate3

### Cookie控制会话管理
特别注意
由于项目部署是分布式的，不能session共享，就用cookie控制了

Cookie中URL解码后内容
一般有4部分
```json
JSESSIONID=6A926CCF6833CBFD17473E4DA13846F7;
managerId=8a801e865c8aefa5015c8bbbb97d0001;
managerWxAccountList=[{"region":"","appId":"wxbb84fc1d0b21d7df","lastUserStatisticsTime":"","qrCode":"","type":"1","blog":"","password":"","url":"","lastGetWXUserAttationtTime":0,"id":"297e51155a4a1da3015a4a21cc060004","certification":"1","loginEmail":"","token":"minshengwxtest","name":"民生微管家","head":"","functionIntroduction":"","appSecret":"0a0ac742091059c196697b5b7fb5e1e8","openId":"gh_9643de2e724d"}];
X6=2017
```

1) Filter实现超时重登录
在LoginFilter中检查名称=X6的Cookie，X6Cookie失效后则重新登录

```java
@Override
    public void doFilter(ServletRequest req, ServletResponse rsp,
            FilterChain chain) throws IOException, ServletException {
        // TODO Auto-generated method stub
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) rsp;
        String url = request.getRequestURL().toString();
        Cookie[] cookies = request.getCookies();
        boolean flag = false;
        boolean boo = false;
        String managerId = null;
        String X6 = null;
        WXManager manager = null;
        url = url.substring(url.lastIndexOf("/") + 1, url.length());

        if(request.getRequestURL().toString().contains("FileUpload_viewImg") ||"brandLogin.jsp".equals(url) || "WXManager_login".equals(url) || "jquery.min.js".equals(url) || "boder.png".equals(url) || "input_new.png".equals(url) || "login.png".equals(url) || "login_button.png".equals(url))
            chain.doFilter(request, response);
        else {
            
            if(cookies != null)
                for(Cookie cookie : cookies) {
                    if("managerId".equals(cookie.getName())) {
                        managerId = cookie.getValue();
                    } else if("X6".equals(cookie.getName())) {
                        X6 = cookie.getValue();
                    }
                }

            if(managerId != null && X6 != null)
                if("2017".equals(X6))
                    flag = true;
            
            if(managerId != null && X6 == null)
                boo = true;

            if(flag) {
                Cookie cookie = new Cookie("X6", "2017");
                //设置X6Cookie有效期30分钟
                cookie.setMaxAge(30*60);
                response.addCookie(cookie);
                chain.doFilter(request, response);
            } else if(boo) {
                //X6Cookie失效后则重新登录
                request.setAttribute("msg", "由于您长时间没有操作，请重新登录，谢谢！");
                request.getRequestDispatcher("/brandLogin.jsp").forward(request, response);
            } else
                request.getRequestDispatcher("/brandLogin.jsp").forward(request, response);

        }
    }
```

### struts2配置

Struts2核心转发请求过滤器`StrutsPrepareAndExecuteFilter`

该核心过滤器相当于SpringMVC的DispatcherServlet前端控制器

鉴于常规情况官方推荐使用StrutsPrepareAndExecuteFilter替代FilterDispatcher，我们此文 将剖析StrutsPrepareAndExecuteFilter，其在工程中作为一个Filter配置在web.xml中，配置如下：
```xml
<filter>  
    <filter-name>struts2</filter-name>  
    <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>  
</filter>  
<filter-mapping>  
    <filter-name>struts2</filter-name>  
    <url-pattern>/*</url-pattern>  
</filter-mapping>  
```
缺少这一配置项目启动将无法访问


struts2中的路径问题 
注意：
`struts2中的路径问题是根据action的路径而不是jsp路径来确定，所以尽量不要使用相对路径 `

例如
```xml
<package name = "noticeRemind" extends = "struts-default" namespace = "/wishgift/action">
    <!-- struts2中的路径问题是根据action的路径来确定 -->
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>
```
所以，后台提供给前台的请求接口命名规则就是`*_*`，第一个占位符`*`代表的字符是用来替换`class="{1}Action"`中的{1}的位置，第二个`*`代表的字符是用来替换`method="{2}"`中的{2}的位置
例如：
`http://10.0.163.176:8083/backMng/gift_list`该请求最终会调用giftAction控制器中的list()方法，并返回数据给客户端


#### package标签中namespace属性的应用
```xml
<package name = "miniProgram" extends = "struts-default" namespace = "/miniprogram/controller">
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>
```




#### Action采用属性驱动
 在Action类中，属性××通过get××()和set××()方法，把参数在整个生命周期内进行传递，这就是属性驱动


### Spring配置

#### Spring使用property文件作为配置源
工程中难免出现一些需要每次部署都需要配置的参数，如数据源连接参数等，测试环境跟实际运行环境是不一样的。
使用spring框架的话，`这些参数可能独立分布在不同的springContex配置文件里面`。
可以考虑将这些参数独立到一个配置文件并可以让spring方便加载注入。可选的一个方案是使用java的property文件，将所有的配置参数都写到property文件里面，使用${key}来在spring配置文件里面得到这个参数。

例子：
property文件global-config-file.properties：
```shell
#FOR dataSource
jdbc.dataSource.url=jdbc:postgresql://192.168.1.118:5432/DB_name
jdbc.dataSource.username=postgres
jdbc.dataSource.password=123
```

示例配置的是数据源参数。
 
之后在springContext的配置文件中，加入下面代码，：
```xml
<!-- 在spring配置文件中 引入xmlns:context命名空间 -->
<beans xmlns:aop="http://www.springframework.org/schema/aop"  xmlns:context="http://www.springframework.org/schema/context">

    <bean id="propertyConfigurer"  
           class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
         <property name="ignoreUnresolvablePlaceholders" value="true" />
         <property name="location" value="classpath:global-config-file.properties"/>  
     </bean>

    <!-- 或者如下 -->
    <bean id="propertyConfig"
        class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>/WEB-INF/classes/dbConection.properties</value>
                <value>/WEB-INF/classes/wifidogcode.properties</value>
                    <!--<value>classpath:jdbc.properties</value> -->
                    <!--<value>classpath:config.properties</value> -->
            </list>
        </property>
    </bean>
</beans>
 ```
即引入PropertyPlaceholderConfigurer来读取property配置文件，spring框架会从其那里获取到需要的配置参数。
之后再用${key}的格式取代你数据源配置参数：
```xml
<bean id="myBatisDataSource" class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="org.postgresql.Driver">
    </property>
    <property name="url" value="${jdbc.dataSource.url}"></property>
    <property name="username" value="${jdbc.dataSource.username}"></property>
    <property name="password" value="${jdbc.dataSource.password}"></property>
</bean>
```
例如：${jdbc.dataSourcurl}：框架会将global-config-file.properties读到jdbc.dataSource.url的值“jdbc:postgresql://192.168.1.118:5432/DB_name”填入${jdbc.dataSource.url}所在的位置。



#### Spring 容器 
相当于一个总配置文件
```xml
<beans>

    <!-- 是用于激活那些已经在spring容器里注册过的bean（无论是通过xml的方式还是通过package scanning的方式）上面的@注解 -->
    <context:annotation-config></context:annotation-config>
    <context:component-scan base-package="wx"></context:component-scan>

    <!-- Properties Start -->
    <bean id="propertyConfig"
        class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>/WEB-INF/classes/dbConection.properties</value>
                <value>/WEB-INF/classes/wifidogcode.properties</value>
<!--                <value>classpath:jdbc.properties</value> -->
<!--                <value>classpath:config.properties</value> -->
            </list>
        </property>
    </bean>

    <bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <!-- hibernate两种映射方式 -->
        <!-- 注解方式(在POJO对象的属性上) -->
        <property name="annotatedClasses">
            <list>
                <value>wx.experiencer.model.Experiencer</value>
            </list>
        </property>
        <!-- hbm.xml配置方式 -->
        <property name="mappingResources">
            <list>
                <value>wx/nationsky/vo/WXManager.hbm.xml</value>
            </list>
        </property>
         <property name="hibernateProperties">
                <props>
                    <prop key="hibernate.dialect">${hibernate.dialect}</prop>
                    <prop key="hibernate.jdbc.fetch_size">${hibernate.jdbc.fetch_size}</prop>
                    <prop key="hibernate.jdbc.batch_size">${hibernate.jdbc.batch_size}</prop>
                </props>
        </property>
    </bean>
    
    <bean id="hibernateTransactionManager"
        class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
    </bean>

    <tx:advice id="txadvice" transaction-manager="hibernateTransactionManager">
        <tx:attributes>
            <tx:method name="save*" propagation="REQUIRED" />
            <tx:method name="add*" propagation="REQUIRED" />
           ...
        </tx:attributes>
    </tx:advice>


    <!-- 给事务配置一个切面 -->
    <aop:config>
        <aop:pointcut expression="(execution (* *.*.service..*(..)))" id="txPointcut" />
        <aop:advisor advice-ref="txadvice" pointcut-ref="txPointcut" />
    </aop:config>

    <!-- 注入HibernaeTemplate实例，作为持久层访问模板 -->
    <bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate">
        <property name="sessionFactory">
            <ref bean="sessionFactory" />
        </property>
    </bean>

    <!-- 引入额外的配置 相当于分模块 使配置结构更加清晰化 -->
    <import resource="wx_spring.xml"/>

</beans>
```

### 事务传播行为

#### PROPGATION_REQUIRED
PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务



例如
```xml
<!-- 微信管理员 -->
<bean id="WXManagerAction" class="wx.wxmanager.action.WXManagerAction" scope="prototype" >      
    <property name="wxManagerService" ref="WXManagerService"></property>
    <property name="wxAccountService" ref="WXAccountService"></property>
    <property name="wxManagerAndWxAccountService" ref="WxManagerAndWxAccountService"></property>
    <property name="logService" ref="SysOparateLogService"></property>
</bean>
<bean id="WXManagerService" class="wx.wxmanager.service.impl.WXManagerServiceImpl"  > 
    <property name="wxManagerDao" ref="WXManagerDao"></property>
</bean>
<bean id="WXManagerDao" class="wx.wxmanager.dao.impl.WXManagerDaoImpl"> 
    <property name="hibernateTemplate" ref="hibernateTemplate"></property>
</bean>
```

### JDBC配置

```properties
hibernate.dialect=org.hibernate.dialect.OracleDialect
 
hibernate.hbm2ddl.auto=update
```
hibernate.hbm2ddl.auto参数的作用
update
最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），
以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。


 

### Hibernate配置
使用POJO对象+hbm.xml，对象属性映射于表中的字段
例如
```xml
<hibernate-mapping>
    <class name = "wx.experiencer.model.Gift" table = "kmh_gift">
        <id name = "id">
            <generator class = "uuid"/>
        </id>
        <property name = "isDirectional"/>
        <property name = "amount"/>
        <property name = "deliveredQuantity" column = "DELIVEREDQUANTITY"/>
        <property name = "detailURL"/>
        <property name = "giftNO"/>
        <property name = "info"/>
        ...
    </class>
</hibernate-mapping>
```

Spring整合Hibernate后，dao组件都默认注入HibernaeTemplate实例，传参时传入VO




### 页面

项目页面以servlet/jsp为主(绝大部分页面中js在scirpt标签嵌入)

```html
<c:forEach items = "${Gifts}" var = "gift">
    <tr style="background-color: FFFFFF; text-align: center;">
        <td class = "Able_Steven_td"><%=i++ %><input name = "gift_Id" type = "hidden" value = "${gift.id }" /><input type = "hidden" name = "gift_orderIndex" value = "${gift.orderIndex}"><c:forEach items = "${gift.types}" var = "type"><input class = "typeIds" type = "hidden" value = "${type.id }"/></c:forEach></td>
        ...
    </tr>
</c:forEach>
```


#### 图片上传
页面form表单中的上传文件控件
```html
<input type="file" name="img" />
```

action中添加两个属性
```java
    private String uploadBasePath = Config.getProperty("giftPic")+"titleIcon/";
    private Logger log = Logger.getLogger(TitleIconAction.class);
    
    //前端上传插件通过struts2属性驱动传入action两个属性(通过setter)
    private File img;
    private String imgFileName;
```

jsp展示页面使用流方式读取
```html
<%@ page import="wx.nationsky.util.Config" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
    String imgBasePath = Config.getProperty("get_img_path"); //读取配置文件中访问mslife_wx(公众号)系统中读取已上传图片的请求接口
%>

<td class="js_td"><img src="<%=imgBasePath%>${title.titleIconImgPath}" height="50" width="80" /></td>
```

#### 页面中表单input标签导致的异常
情景再现

页面中 js 中
pdLimitTime  错误的表单域类型text

导致 表单submit()方法提交数据请求无法进入Action控制器

```js

// pdLimitTime  错误的表单域类型text
tds.eq(43).append($('<input  value = "'+pdTimeLimit+'" type="text" name="gift.pdTimeLimit" class="js_desc Able_Steven_isEmpty numberField"/>'));
```




## mslife_wx_mimiprogram 微信小程序
>前后台完全分离(前台是手机移动端,没有PC浏览器端)
(客户行为)小程序前台客户端调用小程序后台->数据库


# 开发流程

## 3.1. 架构设计

分层开发
按功能分包
命名 wx.功能.xxx
xxx=vo,dao,service,action

### 实体类包
一般名命xx.xx.model或xx.xx.vo


### action层

#### 主要点
- 基本上不用ajax，都使用的是jsp/Servlet的request，session等作用域
- 一些表单验证(如id，名称唯一性验证)，请求后台接口使用ajax

#### Struts2框架下请求接口命名模式
struts.xml配置 action属于哪一个 namespace下面 xxx_yyy
对应xxxAction中的yyy方法
例如:
`miniGift_add`
配置方式
```xml
<package name="nationsky" extends="struts-default" namespace="/">
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>

<package name="experiencer" extends="struts-default" namespace="/experiencer/action">
    <action name="*_*" class="{1}Action" method="{2}">
        <result name="success">${result}</result>
        <result name="redirect" type="redirectAction">${result}</result>
        <result name="chain" type="chain">${result}</result>
        <result name="input">${result}</result>
    </action>
</package>
```
`/experiencer/action`和experience.action并不是相对应

`namespace="/"` 实际转发到 / namespace下面

#### 基础Action类 BaseAction
//日志文件 1成功 2失败 //左边菜单列表 //分页对象 //当前页对象 //页面返回值(result路径,控制器分发时使用->${result})

#### 文件上传示例
前端jsp中form表单的input表单域上传控件
`<input type="file" name="img" class="txt" style="width:60px;" value="">`

```java
@Component
@Scope("prototype")
public class TitleIconAction extends BaseAction {
    private File img;
    private String imgFileName;

    //属性的getter setter方法
    public File getImg() {
        return img;
    }

    public void setImg(File img) {
        this.img = img;
    }

    public String getImgFileName() {
        return imgFileName;
    }

    public void setImgFileName(String imgFileName) {
        this.imgFileName = imgFileName;
    }

    public String add() {
        //验证vo对象属性titleIcon 图片非空
        if (null == titleIcon || null == img || imgFileName.equals("")){
            this.addActionMessage("图片不能为空");
            log.info("======= exception for add() of " + TitleIconAction.class.toString() + "图片不能为空");
            result = "titleIcon_forTitleIconListPage";
            return "chain";
        }

        try {
            //使用文件上传工具类获取存储磁盘后的String类型的图片存储路径
            String imgPath = ImgUtility.saveImg(img, imgFileName, uploadBasePath);
            //给VO对象赋值上传图片的路径
            titleIcon.setTitleIconImgPath(imgPath);
            service.saveTitleIcon(titleIcon);
            result = "titleIcon_forTitleIconListPage";
        } catch(Throwable e) {
            PrintErr.printErr(e, log);
            result = "brandManage/brandMain.jsp";
            return SUCCESS;
        }
    }
}
```
上传文件需要传递参数 (img imgFileName分别对应action中File类型，String类型属性)


Spring在Action上面注解@Scope("prototype")
表示每次接收一个请求创建一个Action对象..
如若改成其他,例如单例模式,则很多请求公用同一个Action.

```java
@Component
@Scope("prototype")
public class TitleIconAction extends BaseAction {
}
```

### service层
声明式事务配置AOP切面在Service层的方法

```xml
<!-- 给事务配置一个切面 -->
<aop:config>
    <aop:pointcut expression="(execution (* *.*.service..*(..)))" id="txPointcut" />
    <aop:advisor advice-ref="txadvice" pointcut-ref="txPointcut" />
</aop:config>
```

#### service层可配置内容
可以在service层添加验证逻辑，在Action层调用
```java
public boolean validateForm(GoodsInfo good) {
        boolean flag = false;
        //验证vo对象属性礼品编号或名称非空
        if (null == good || "".equals(good.getGoodsNo()) || "".equals(good.getName())){
            log.info("======= exception for validateForm() of " + MiniGiftServiceImpl.class.toString() + "礼品编号或名称不能为空");
            flag = true;
        }

        //可扩展其他的验证
        //...
        return flag;
    }
```

### dao层
基础dao类 BaseDaoImpl(多例)
```java
/**
 * 顶层持久化层实现类
 * @author xiaohuiyang
 *
 */
@Component
@Scope("prototype")
public abstract class BaseDaoImpl extends HibernateDaoSupport implements BaseDao {
    private Logger log = Logger.getLogger(TitleIconDaoImpl.class);

}
```

注入HibernaeTemplate实例，作为持久层访问模板
```java
@Override
public TitleIcon findById(String id) {
    log.info("======= log for findById() of " + TitleIconDaoImpl.class);

    TitleIcon titleIcon = null;
    try {
        //使用注入的HibernateTemplate实例执行持久化操作，传参时传入VO
        titleIcon = (TitleIcon) getHibernateTemplate().get(TitleIcon.class, id);
    } catch (Exception e) {
        //使用PrintErr工具类打印异常到日志
        PrintErr.printErr(e, log);
    } finally {
        flushSession();
        clearSession();
    }

    log.info("======= log for findById() of " + TitleIconDaoImpl.class + "ends.");
    return titleIcon;
}
```

注意事务管理
Spring容器配置事务传播行为统一使用 PROPGATION_REQUIRED
`  <tx:method name="save*" propagation="REQUIRED" />`

PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务


### Oracle数据库层

#### Oracle服务名
通常是全局数据库名

#### Oracle实例是什么
(内存结构+一系列进程结构)
安装好oracle后，需要配置一个数据库，数据库是静态的，具体就是存储在硬盘的一系列文件；启动数据库即启动一个实例，就是运行起来的一系列管理数据库的后台进程和内存区域


#### Hibernate配置id生成策略
使用Hibernate配置id生成策略都是用uuid
例如：GoodsInfo就采用的是uuid
```xml
<hibernate-mapping>
<class name = "wx.miniprogram.model.GoodsInfo" table = "PDD_GOODSINFO">
    <id name = "id">
        <generator class="uuid"/>
    </id>
    <property name = "name"/>
    <property name = "goodsNo"/>
    <property name = "price"/>
    <property name = "pdPrice"/>
    <property name = "pdPeoples"/>
    <property name = "initInventory"/>
    <property name = "residualInventory"/>
    <property name = "pdTimeLimit"/>
    <property name = "listPic"/>
    <property name = "detailUrl"/>
    <property name = "orderIndex"/>
    <property name = "onSaleTime"/>
    <property name = "offSaleTime"/>
</class>
</hibernate-mapping>
```


数据库服务器
oracle11g SIMPLIFIED CHINESE_CHINA.ZHS16GBK
编码使用


客户端
推荐使用PL/SQL客户端(注：需要下载32位oracle客户端压缩包，配置方式百度之)

注:
`盘符:\...\客户端解压目录\product\11.2.0\client_1\bin;`路径要加入到系统Path变量中

新建一个bat批处理，设置数据库client编码(session的级别)
```shell
set NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK
"F:\PLSQL Developer\plsqldev.exe"
```

#### Oracle导入导出dmp文件

装了oracle客户端(instantclient_11_2 须下载)后，
使用exp导出数据
使用imp导入数据 
```sql
exp wxcedb/wxcedb@10.0.12.31:1521/testlis file=d:\daochu.dmp full=y

imp home/xb101406@10.243.5.101:1521/xe  file=f:\daochu.dmp full=y
```




## 3.2. 简单开发示例设计

`示例设计_鑫愿贺卡_商城标题图管理`

### 功能开发

在wx.wishgift.action包下面新增

titleIconList.jsp
TitleIconAction(Struts2控制器)
```java
package wx.wishgift.action;

@Component
@Scope("prototype")
public class TitleIconAction extends BaseAction {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    @Autowired
    private TitleIconService service;

    private String uploadBasePath = Config.getProperty("giftPic")+"titleIcon/";
    private Logger log = Logger.getLogger(TitleIconAction.class);
    
    private List<TitleIcon> titles;
    private TitleIcon titleIcon;
    private String titleIconId;
    private File img;
    private String imgFileName;

    //********* Getter And Setter ***********
    
    public List<TitleIcon> getTitles() {
        return titles;
    }

    public void setTitles(List<TitleIcon> titles) {
        this.titles = titles;
    }

    public TitleIcon getTitleIcon() {
        return titleIcon;
    }

    public void setTitleIcon(TitleIcon titleIcon) {
        this.titleIcon = titleIcon;
    }

    //******** Request Handler ***********
    
    public String forTitleIconListPage() {
        log.info("=======log for forTitleIconListPage()");

        titles = service.listAllTitles();
        result = "page/wishgift/titleIconList.jsp";

        log.info("=======log for forTitleIconListPage() ends");
        return SUCCESS;
    }

    //新增方法
    public String add() {
        log.info("======= log for add() of " + TitleIconAction.class.toString());

        //验证vo对象属性titleIcon 图片非空
        if (null == titleIcon || null == img || imgFileName.equals("")){
            this.addActionMessage("图片不能为空");
            log.info("======= exception for add() of " + TitleIconAction.class.toString() + "图片不能为空");
            result = "titleIcon_forTitleIconListPage";
            return "chain";
        }

        //验证vo对象属性titleIconId是否已存在 true 说明库中没有
        if (service.uniqueTitleIconId(titleIconId)){
            try {
                String imgPath = ImgUtility.saveImg(img, imgFileName, uploadBasePath);

                //给VO对象赋值上传图片的路径
                titleIcon.setTitleIconImgPath(imgPath);

                service.saveTitleIcon(titleIcon);

                result = "titleIcon_forTitleIconListPage";
            } catch(Throwable e) {
                PrintErr.printErr(e, log);
                result = "brandManage/brandMain.jsp";
                return SUCCESS;
            }
        } else {
            this.addActionMessage("该titleIconId已存在");
            result = "该titleIconId已存在";
            return INPUT;
        }


        log.info("======= log for add() of " + TitleIconAction.class.toString() + " ends.");
        return "redirect";
    }

    //其他控制器方法，修改，删除，等方法

    }
}

```

TitleIconService
```java
package wx.wishgift.service;

import java.util.List;

import wx.nationsky.service.BaseService;
import wx.wishgift.model.TitleIcon;

public interface TitleIconService extends BaseService {
    List<TitleIcon> listAllTitles();

    TitleIcon findById(String id);
    boolean uniqueTitleIconId(String titleIconId);
    boolean saveTitleIcon(TitleIcon titleIcon);
    boolean updateTitleIcon(TitleIcon titleIcon);
    boolean deleteTitleIcon(TitleIcon titleIcon);
}
```
TitleIconDao
```java
package wx.wishgift.dao;

import java.util.List;

import wx.nationsky.dao.BaseDao;
import wx.wishgift.model.TitleIcon;

public interface TitleIconDao extends BaseDao {
    List<TitleIcon> findAll();
    TitleIcon findById(String titleIconId);
    boolean uniqueTitleIconId(String titleIconId);
    boolean saveTitleIcon(TitleIcon titleIcon);
    boolean updateTitleIcon(TitleIcon titleIcon);
    boolean deleteTitleIcon(TitleIcon titleIcon);
}
```


### 数据表
KMH_TITLEICON


### 使用POSTMAN进行开发后台接口

从JSP--TitleIconAction--TitleIconService--TitleIconDao--Oracle


## 3.3 接口开发示例

### mslife_wx 公众号
该项目的请求接口统一使用
`ip:端口/项目名称/控制器名称/requestMapping名称.json`
的格式


springmvc是基于servlet，web.xml中配置一个servlet，会做请求分发，还有一系列其它处理
因为该项目使用SpringMVC，并且在web.xml中配置如下
```xml
<!--springmvc的核心是DispatcherServlet，它负责控制整个页面的请求路径-->  
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
     <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:resource/spring/spring-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>*.json</url-pattern>
</servlet-mapping>
```


### mslife_wx_back_management 微管家后台系统
该项目的请求接口统一使用
`http://ip:端口/项目名称/Action名称(不带Action后缀)_Action中方法名称`
的格式


### mslife_wx_mimiprogram 微信小程序



### 接口文档
主要结构
包括接口功能名称，接口调用请求说明，请求方式，请求参数说明，返回说明，返回参数说明

获取商城标题图列表

接口调用请求说明
`http://mswgj.minshenglife.com/mslife_wx/titleIcon/getTitleIconList.json`

请求方式：GET

请求参数说明
参数  是否必须    说明

返回说明
```json
{
    "status": {
        "code": 0,
        "msg": ""
    },
        "data":{
            "titleIconList":[
{"titleIconId":"8a8023055fb47f23015fb4c74e840001","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/f6f24b33.50bb.4dc0.b414.00df251b9b7a-1922236980.jpg","titleIconURL":"111","titleIconSort":-1},
{"titleIconId":"8a8023055fb47f23015fb480b6980000","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/a959bccd.5005.4c46.9f5c.1936223a63811848602103.jpg","titleIconURL":"999","titleIconSort":0},
{"titleIconId":"8a8023055fb40b10015fb45a535c0001","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/7a75f9ac.1b9a.4a2e.b681.14d6aa9dd127-423361007.jpg","titleIconURL":"777","titleIconSort":1},
{"titleIconId":"8a8023055fb40b10015fb458e5dc0000","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/7b85ca1a.9df3.480a.82e0.37a3566cfa111531658263.jpg","titleIconURL":"666","titleIconSort":1},
{"titleIconId":"2","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/6dc2d733.9d44.420d.ac28.ceea17c1cca01351015038.jpg","titleIconURL":"Wildhorse","titleIconSort":2},
{"titleIconId":"8a8024595fb83330015fb83981c10000","titleIconImgPath":"/datafile/flyingstart/gift/titleIcon/51f0b149.4767.4f2b.b10f.a02578e346bb-1345260926.jpg","titleIconURL":"gyjh少林寺","titleIconSort":9}
        ]
    }
}
```

返回参数说明：
参数  说明
code    0：成功
msg 
titleIconList   返回的商城标题图list
titleIconId 商城标题图id
titleIconImgPath    标题图存储路径
titleIconURL    标题图用户输入的URL
titleIconSort   标题图用户输入的排序(值越小越靠前)



更多其他接口文档请参照
`民生保险项目文档/接口文档/`下面的接口文档

## 3.4. 开发注意的易错点

### 页面jsp脚本注意点

#### form表单
form表单中，input表单项在初始化和编辑时，表单域类型类型要保持一致



# 测试流程


测试版本都要部署到测试服务器上，每次系统上测试服务器需要先更新SVN库最新代码后编译打包部署到服务器(可以和江海波沟通一下)

各个项目对应服务器地址如下，可通过xshell链接操作：
公众号&&后台管理 ssh:
ip:10.0.158.27 

账号：weblogic
密码：password weixin

小程序测试环境：
ip:10.0.158.26 

账号：wxusr
密码：password


部署方法
```shell
cd /data
mv mslife_wx.war 备份名
rz -y 
ps ef|grep java
kill -9 进程号
nohup ./startWebLogic.sh > nohup.out  2>&1 &
```


# 部署运维流程



# 模块指南

## 微管家后台管理系统

- 鑫愿贺卡
    + 礼物管理
    + 供应商礼品管理
    + 供应商管理
    + 公告管理
    + 提示按钮的设置
    + 中支管理
    + 集采订单管理
    + 中支集采订单管理
    + 积分红包卡充值记录
    + 问答管理
    + 商城标题图管理
    + 统计报表
- 微信公众号管理
    + 账号添加
    + 账号编辑
    + 设置OpenID
- 小程序管理
    + 小程序礼物管理
