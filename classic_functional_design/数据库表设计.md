
## 表


## 基本表的性质

基本表与中间表、临时表不同，因为它具有如下四个特性：

(1) 原子性。基本表中的字段是不可再分解的。

(2) 原始性。基本表中的记录是原始数据（基础数据）的记录。

(3) 演绎性。由基本表与代码表中的数据，可以派生出所有的输出数据。

(4) 稳定性。基本表的结构是相对稳定的，表中的记录是要长期保存的。

理解基本表的性质后，在设计数据库时，就能将基本表与中间表、临时表区分开来。


## 中间表的由来

那么，这些中间表是如何出现的？为什么中间表会越来越多？中间表会给项目组带来什么样的困扰，如何解决这些困扰？这里我们就尝试探讨一下这个问题。


### 中间表出现的典型场景主要有三个

 一步算不出来。数据库中的原始数据表要经过复杂计算，才能在报表上展现出来。一个SQL很难实现这样的复杂计算。要连续多个SQL实现，前面的生成中间表给后边的SQL使用。

 实时计算等待时间过长。因为数据量大或者计算复杂，报表用户等待时间太长。所以要每天晚上跑批量任务，把数据计算好之后存入中间表。报表用户基于中间表查询就会快很多。

 多样性数据源参加计算。来自于文件、NOSQL、Webservice等的外部数据，需要与数据库内数据进行混合计算时，传统办法只能导入数据库形成中间表。




## 字段

1 属性用布尔型的扩展问题
问：
你说的属性用布尔型的扩展问题
为什么叫做 cancelState ？
直接通过 cancel字段的布尔值 不就可以判断  取消状态？

答：
如果产品经理或客户要改需求，从是否取消，改成：未取消、申请取消、取消中、已取消，你怎么办？所以尽量少用布尔型，不要给自己挖坑！

如果字段是boolean类型，不要使用is前缀，实体生成工具产生getter/setter方法时可能会出现意想不到的结果。

## 约束

所有约束都要命名，而不要依赖数据库系统默认生成的名字。这里提及的表名不要带tb_前缀

### 检查约束Check Constraints
ck_<表名>_<列名>_<描述>，比如订单表的订单号只能大于零，可以这样命名如下：
ck_orders_orderid_gt_zero

### 非空约束Not-Null Constraints
nn_<表名>_<列名>
注：因为PostgreSQL在违反非空约束时，根本不提及非空约束的名字，所以非空约束在PostgreSQL中可以不命名。

### 唯一约束Unique Constraints
uk_<表名>_<列名>,如果是组合字段，则把所有的字段都添加到后面，用下划线分隔。

### 主键约束Primary Keys
pk_<表名>，因为主键只有一个，可以不用指名主键字段名。一个表只能有一个单一字段主键，而且一定要把主键放在表的第一个字段。

### 外键约束Foreign Keys
fk_<子表名(本表)>_<父表名>_<引用字段名>
