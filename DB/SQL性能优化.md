

## SQL性能优化几条经验

### 查询的模糊匹配

尽量避免在一个复杂查询中使用LIKE ‘%param1%’ 红色标识位置的百分号会导致相关列的索引无法使用，最好不要用。

解决办法：
其实只需要对该脚本略做改进，查询速度便会提高近百倍。如下：

a 修改前台程序
把查询条件的供应商名称一栏由原来的文本输入改为下拉列表，用户模糊输入供应商名称时，在前台就帮忙定位到具体吊供应商，这样在调用后台程序时，这个列就可以直接用等号来关联了。

b 直接修改后台
根据输入条件，先查出符合条件的供应商，并把相关记录保存在一个临时表中，让那后再用临时表去做复杂关联。


### 索引问题

在做性能跟踪分析过程中，经常发现有不少后台程序的性能问题是因为缺少合适索引造成的，有些表甚至一个索引都没有。这种请求往往都是因为在设计表时，没去定义索引，而开发初期，由于表记录很少，索引创建与否，可能对性能没啥影响，开发人员因此也为多加重视。然而一旦程序发布到生产环境，随着时间的推移，表记录越来越多。

这是缺少索引，对性能的影响越来越大。

这个问题就需要数据库设计人员和开发人员共同关注

法则：不要再建立的索引的数据列上进行下列操作：
* 避免对索引字段进行计算操作
* 避免在索引字段上使用not, <>, !=
* 避免在索引字段上使用IS NULL和IS NOT NULL
* 避免在索引列上出现数据类型转换
* 避免在索引字段上使用函数
* 避免在索引的列中使用空值


### 复杂操作

部分UPDATE, SELECT语句写的很复杂(经常嵌套多级子查询)--可以适当考虑拆成几步，先生成一些临时数据表，在进行关联操作


### 在可以使用UNION ALL的语句里，使用了UNION
UNION因为会将各查询子集吊记录做比较，故比起UNION ALL，通常速度都会慢上许多。
一般来说，如果使用UNION ALL能满足要求的话，无比使用UNION ALL。还有一种情况大家可能会拉忽略掉，就是虽然要求及个子集的并集需要过滤掉重复记录，但由于脚本的特殊性，不可能存在重复记录，这时便应该使用UNION ALL，


### 在WHERE语句中，尽量避免对索引字段进行计算操作


### 对WHERE语句的法则

* 避免在WHERE子句中使用in, not in, or或者having
可以使用exist和not exist代替in和not in
可以使用表链接代替exist. having可以用where代替，如果无法代替可以分两步处理.


* 不要以字符格式声明数字，要以数字格式声明字符值。(日期同样)否则会使索引失效，产生全表扫描。

例子:
```sql
SELECT emp.ename, emp.job FROM emp WHERE emp.empno = 7369;

--不要使用:SELECT emp.ename, emp.job FROM emp WHERE emp.empno = '7369'
```

