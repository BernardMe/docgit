



# 多线程实现方式

## A继承Thread类

### 程序构成
测试类(main方法)
火车票售卖类(extends线程类)

### 运行结果
ticThread.TestTicket
窗口B卖了1张票
窗口A卖了1张票
窗口B卖了2张票
窗口A卖了2张票
窗口B卖了3张票
窗口A卖了3张票
窗口B卖了4张票
窗口A卖了4张票
窗口B卖了5张票
窗口A卖了5张票
...
窗口B卖了199张票
窗口B卖了200张票

## 问题
由于未考虑线程同步问题，出现了A，B窗口各卖了200张票的情况

## B实现Runnable接口创建线程
 因为Runnable接口只有run() 方法 没有start()方法
 传入同一个Runnable实例

### 程序构成
测试类(main方法)
火车票售卖类(实现Runnable接口)

方案：引入同步锁
 *
 *  [*使用synchronized关键字修饰方法
 *    执行该方法的过程之中，当前对象this被锁定]

## 问题
问题1 有可能出现卖出 201 张 情况

## C实现Runnable接口创建线程 (使用共享资源类对象)
  1.使用synchronized代码块, 使得单一线程锁定对共享资源的访问
  2.同步代码块参数要求的类型是Object，基本数据类型不能直接给Object，
  3.把共享资源看成是类，创建对象传入synchronized代码块 作为对象锁
  4.建议使用这种类型

### 程序构成
测试类(main方法)
火车票类
火车票售卖类(实现Runnable接口，使用同步代码块)



## 线程局部存储

TLS
thread local storage

TSD
thread special data

TLS/TSD算是从一个新的作用域定义一种变量存储类型，即该变量在线程的作用域上进行隔离，不同的线程的该类型变量相互隔离\独立。

### why?
多线程下线程安全通常采用以下两种方式
- 如果多线程间有数据同步需求，通常采用全局变量+锁机制
- 如果线程间处理数据相互独立，线程内数据处理通过采用局部变量，或者通过传参的方式(实际也是局部变量)

针对第2种情况，有时候线程处理数据增加时，通常需要改接口，添加参数(或者是接口设计不好)，采用TLS/TSD可以避免这种问题，线程处理函数内部时数据可以通过TLS/TSD进行传递，避免修改接口通过传参数，同时又可以实现各个线程间数据隔离。



## Java中ThreadLocal类

### 一、概述
ThreadLocal是什么呢？其实ThreadLocal并非是一个线程的本地实现版本，它并不是一个Thread，而是threadlocalvariable(线程局部变量)。也许把它命名为ThreadLocalVar更加合适。线程局部变量(ThreadLocal)其实的功用非常简单，就是为每一个使用该变量的线程都提供一个变量值的副本，是Java中一种较为特殊的`线程绑定机制`，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。
 
从线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。

通过ThreadLocal存取的数据，总是与当前线程相关，也就是说，JVM为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出现的并发访问问题提供了一种隔离机制。

ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现思路很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。

概括起来说，对于多线程资源共享的问题，同步机制采用了"以时间换空间"的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

